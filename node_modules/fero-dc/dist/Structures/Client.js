"use strict";
/**
 * MIT License
 *
 * Copyright (c) 2021 Ferotiq
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @format
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const Discord = __importStar(require("discord.js"));
const dotenv = __importStar(require("dotenv"));
dotenv.config();
const FDCConsole_js_1 = require("./FDCConsole.js");
const fs = __importStar(require("fs"));
require("colors");
const path = __importStar(require("path"));
const builtInHelpCommand_js_1 = require("../Scripts/builtInHelpCommand.js");
const fero_ms_1 = require("fero-ms");
const lodash_1 = __importDefault(require("lodash"));
const none = [null, undefined];
class Client extends Discord.Client {
    fdcconsole = new FDCConsole_js_1.FDCConsole();
    commands = new Discord.Collection();
    discord = Discord;
    defaultPrefix;
    prefixes = new Discord.Collection();
    commandLoadedMessage;
    eventLoadedMessage;
    emitMessageOnInteraction;
    builtInHelpCommand;
    deleteUnusedSlashCommands;
    paths;
    modules;
    permissionData;
    config;
    started = false;
    converters = {
        string: resolveString,
        mstring: resolveMString,
        quote: resolveQuote,
        char: resolveChar,
        number: resolveNumber,
        int: resolveInt,
        float: resolveNumber,
        boolean: resolveBoolean,
        color: resolveColor,
        guild: resolveGuild,
        member: resolveMember,
        user: resolveUser,
        channel: resolveChannel,
        message: resolveMessage,
        invite: resolveInvite,
        emoji: resolveEmoji,
        role: resolveRole,
        permission: resolvePermission,
        time: resolveTime,
        command: resolveCommand
    };
    converterDescriptions = {
        string: "string",
        mstring: "string",
        char: "single character",
        number: "number",
        int: "integer (whole number)",
        float: "floating-point (decimal) number",
        boolean: "true/false",
        color: "hexadecimal color",
        guild: "server",
        member: "server member",
        user: "discord user",
        channel: "channel",
        message: "message",
        invite: "server invite",
        emoji: "emoji",
        role: "server role",
        permission: "permission string",
        time: "date",
        command: "fero-dc command"
    };
    constructor(paths, modules = {}) {
        if (!fs.existsSync(paths.config)) {
            const toMake = path.join(paths.config, "../");
            fs.mkdirSync(toMake, { recursive: true });
            fs.writeFileSync(paths.config, JSON.stringify({
                tokenName: "TOKEN",
                prefix: "!",
                permissionData: {},
                intents: ["GUILDS", "GUILD_MESSAGES"]
            }, null, 4));
        }
        const envPath = path.join(process.cwd(), ".env");
        if (!fs.existsSync(envPath)) {
            fs.writeFileSync(envPath, "# Auto-Generated ENV\nTOKEN = BOTTOKEN");
            dotenv.config();
        }
        const config = JSON.parse(fs.readFileSync(paths.config)?.toString());
        if (!config)
            throw new FDCConsole_js_1.FDCError("You did not supply a valid config path!");
        super(config);
        this.defaultPrefix = config.prefix;
        if (!config.tokenName)
            throw new FDCConsole_js_1.FDCError("A token name in the config.json was not provided.");
        if (!process.env[config.tokenName || "TOKEN"])
            throw new FDCConsole_js_1.FDCError(`No .env ${config.tokenName} was provided.`);
        const { commandLoadedMessage, eventLoadedMessage, builtInHelpCommand, deleteUnusedSlashCommands } = config;
        this.commandLoadedMessage = commandLoadedMessage;
        this.eventLoadedMessage = eventLoadedMessage;
        this.builtInHelpCommand = builtInHelpCommand;
        this.deleteUnusedSlashCommands = deleteUnusedSlashCommands;
        this.paths = paths;
        this.modules = modules;
        if (!config.permissionData)
            throw new FDCConsole_js_1.FDCError("Permission data in the config.json was not provided.");
        this.permissionData = config.permissionData;
        this.config = config;
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        Object.entries(this.paths).forEach(p => {
            if (!fs.existsSync(p[1])) {
                fs.mkdirSync(p[1], { recursive: true });
                this.fdcconsole.warn(`${p[0]} directory "${p[1]}" didn't exist, creating it...`
                    .yellow);
            }
        });
        this.login(process.env[this.config.tokenName || "TOKEN"]);
        this.once("ready", async () => {
            this.fdcconsole.log(`${this.user.username} is online!`.magenta);
            const result = await this.reload();
            this.fdcconsole.log(result.blue);
        });
    }
    async reload() {
        console.time("Fero-DC Reload");
        this.commands.clear();
        const slashCommands = await this.application.commands.fetch();
        console.timeLog("Fero-DC Reload", "Fetching SlashCommands");
        const commands = (await Promise.all(fs
            .readdirSync(this.paths.commands)
            .filter(file => isJSOrDirectory(path.join(this.paths.commands, file)))
            .map(async (folder) => {
            if (isJS(folder))
                return require(path.join(this.paths.commands, folder));
            else
                return await Promise.all(fs
                    .readdirSync(path.join(this.paths.commands, folder))
                    .filter(file => isJS(file))
                    .map(file => require(path.join(this.paths.commands, file))));
        })))
            .flat(1)
            .map(cmd => (typeof cmd["command"] == "object"
            ? cmd["command"]
            : cmd));
        commands.forEach(cmd => {
            if (!cmd || lodash_1.default.isEmpty(cmd) || !cmd.name)
                return this.fdcconsole.warn("Command file with no command identified. Could not load.");
            this.commands.set(cmd.name, cmd);
            const slashCommand = slashCommands.find(c => c.name.toLowerCase() == cmd.name.toLowerCase());
            if (cmd.isSlash() && !slashCommand) {
                this.application.commands.create({
                    name: cmd.name,
                    description: cmd.description,
                    type: "CHAT_INPUT",
                    options: cmd.slashCommandOptions,
                    defaultPermission: true
                });
                this.fdcconsole.warn(`Command ${cmd.name} isn't registered as a slash command, creating it...`
                    .yellow);
            }
            else if (cmd.isSlash() && slashCommand) {
                if (!(cmd.description == slashCommand.description &&
                    arrayEquals(cmd.slashCommandOptions, slashCommand.options))) {
                    slashCommand.edit({
                        name: cmd.name,
                        description: cmd.description,
                        type: "CHAT_INPUT",
                        options: cmd.slashCommandOptions,
                        defaultPermission: true
                    });
                    this.fdcconsole.log(`Edited slash command ${cmd.name}...`.green);
                }
            }
        });
        if (this.builtInHelpCommand) {
            const helpCommand = builtInHelpCommand_js_1.builtInHelpCommand(this);
            if (this.commands.find(cmd => cmd.name.toLowerCase() == helpCommand.name ||
                cmd.aliases.map(lower).includes(helpCommand.name)))
                throw new FDCConsole_js_1.FDCError("You are attempting to override a custom help command with the default help command, please choose one or the other.");
            this.commands.set(helpCommand.name, helpCommand);
            if (helpCommand.isSlash() && !helpCommand.slashCommandOptions)
                this.application.commands.create({
                    name: helpCommand.name,
                    description: helpCommand.description,
                    type: "CHAT_INPUT",
                    options: helpCommand.slashCommandOptions,
                    defaultPermission: true
                });
        }
        console.timeLog("Fero-DC Reload", "Commands and Editing/Deleting SlashCommands");
        slashCommands.forEach(slashCommand => {
            const cmd = commands.find(cmd => cmd.name.toLowerCase() == slashCommand.name.toLowerCase() &&
                cmd.isSlash());
            if (!cmd &&
                this.deleteUnusedSlashCommands &&
                !(cmd.name == "help" && this.builtInHelpCommand))
                slashCommand.delete() &&
                    this.fdcconsole.warn(`Deleted slash command ${slashCommand.name}...`.yellow);
        });
        console.timeLog("Fero-DC Reload", "Creating SlashCommands");
        const events = (await Promise.all(fs
            .readdirSync(this.paths.events)
            .filter(file => isJSOrDirectory(`${this.paths.events}/${file}`))
            .map(async (folder) => {
            if (isJS(folder))
                return require(`${this.paths.events}/${folder}`);
            else
                return await Promise.all(fs
                    .readdirSync(`${this.paths.events}/${folder}`)
                    .filter(file => isJS(`${this.paths.events}/${folder}/${file}`))
                    .map(file => require(`${this.paths.events}/${folder}/${file}`)));
        })))
            .flat(1)
            .map(event => (typeof event.event == "object"
            ? event.event
            : event));
        this.removeAllListeners();
        events.forEach(event => {
            if (!event || lodash_1.default.isEmpty(event) || !event.event)
                return this.fdcconsole.warn("Event file with no event identified. Could not load.");
            this.on(event.event, event.run.bind(null, this));
        });
        console.timeLog("Fero-DC Reload", "Events");
        console.table(Object.fromEntries(this.commands.map(cmd => [cmd.name, cmd])), [
            "description",
            "aliases",
            "permissions",
            "category",
            "type",
            "args",
            "slashCommandOptions"
        ]);
        console.table(Object.fromEntries(events.map(event => [event.event, event])), ["run"]);
        Object.assign(this, this.modules);
        console.timeEnd("Fero-DC Reload");
        this.emit("ready", this);
        return `Reloaded ${commands.length} commands, ${events.length} events, and ${Object.keys(this.modules).length} modules.`;
    }
    checkPermissions(permissions, member) {
        if (!member || !(member instanceof Discord.GuildMember))
            return false;
        return permissions.some(permission => {
            if (typeof permission == "string")
                return this.checkPermission(permission, member);
            else if (permission instanceof Array)
                return permission.every(perm => this.checkPermission(perm, member));
        });
    }
    checkPermission(permission, member) {
        if (this.users.cache.get(permission))
            return member.id == permission;
        else if (member.guild.roles.cache.get(permission))
            return member.roles.cache.has(permission);
        else if (this.permissionData[permission])
            return this.checkPermissions(this.permissionData[permission], member);
        else
            return member.permissions.has(permission, true);
    }
    async runCommand(command, message, args) {
        const conversions = (await Promise.all(command.args.map(async (argument, index) => await this.converters[argument.type]({
            client: this,
            string: args[index],
            message: message,
            rest: args.slice(index + 1)
        })))) || [];
        return command.run(message, args, this, ...conversions);
    }
    getCommandsFromCategory(category) {
        return this.commands.filter(command => command.category == category);
    }
    getCommandUsage(command, guild = null) {
        if (!command)
            return;
        const prefix = this.prefix(guild);
        const cmdArgs = command.args
            .map(commandArg => `<${commandArg.name}${commandArg.required ?? true ? "" : "?"}: ${commandArg.type}>`)
            .join(" ");
        return (command.usage ||
            `${prefix}${command.name}${cmdArgs == "" ? "" : " " + cmdArgs}`);
    }
    prefix(guild = null) {
        return guild
            ? typeof guild == "string"
                ? this.prefixes.get(guild) || this.defaultPrefix
                : this.prefixes.get(guild.id) || this.defaultPrefix
            : this.defaultPrefix;
    }
    loadPrefixes(...iterators) {
        iterators.forEach(iterator => {
            if (iterator instanceof Discord.Collection) {
                iterator.forEach((v, k) => {
                    if (typeof v != "string")
                        return;
                    if (typeof k != "string" && !(k instanceof Discord.Guild))
                        return;
                    if (k instanceof Discord.Guild)
                        this.prefixes.set(k.id, v);
                    else
                        this.prefixes.set(k, v);
                });
            }
            else if (iterator instanceof Array) {
                iterator.forEach(i => {
                    const [k, v] = i;
                    if (typeof v != "string")
                        return;
                    if (typeof k != "string" && !(k instanceof Discord.Guild))
                        return;
                    if (k instanceof Discord.Guild)
                        this.prefixes.set(k.id, v);
                    else
                        this.prefixes.set(k, v);
                });
            }
            else if (iterator instanceof Map) {
                iterator.forEach((v, k) => {
                    if (typeof v != "string")
                        return;
                    if (typeof k != "string" && !(k instanceof Discord.Guild))
                        return;
                    if (k instanceof Discord.Guild)
                        this.prefixes.set(k.id, v);
                    else
                        this.prefixes.set(k, v);
                });
            }
            else if (typeof iterator == "object") {
                Object.entries(iterator).forEach(i => {
                    const [k, v] = i;
                    if (typeof v != "string" || typeof k != "string")
                        return;
                    this.prefixes.set(k, v);
                });
            }
            else
                throw new FDCConsole_js_1.FDCError("loadPrefixes was not passed an object, array, map, or collection.");
        });
        return this.prefixes;
    }
    get commandCategories() {
        return [
            ...new Set(this.commands
                .map(c => c.category)
                .filter(c => !none.includes(c)))
        ];
    }
}
exports.Client = Client;
function isJS(fileName) {
    return [".js", ".ts"].includes(path.extname(fileName));
}
function isDirectory(filePath) {
    return fs.lstatSync(filePath).isDirectory();
}
function isJSOrDirectory(filePath) {
    return isJS(filePath) || isDirectory(filePath);
}
function arrayEquals(a, b) {
    return a.every((val, index) => lodash_1.default.isEqual(val, b[index]));
}
function resolveString(options) {
    return options.string;
}
function resolveMString(options) {
    return (options.string + " " + options.rest.join(" ")).trim();
}
const regex = /"([^"]+)"/;
function resolveQuote(options) {
    const matches = resolveMString(options).match(regex);
    if (!matches)
        return null;
    return matches[1];
}
function resolveChar(options) {
    return options.string[0] ?? null;
}
function resolveNumber(options) {
    return parseFloat(options.string);
}
function resolveInt(options) {
    return parseInt(options.string);
}
const falsy = [
    "false",
    "0",
    "0n",
    "undefined",
    "NaN",
    "",
    "no",
    "off",
    ...none
];
function resolveBoolean(options) {
    return none.includes(options.string)
        ? null
        : !falsy.includes(options.string);
}
function resolveColor(options) {
    return Discord.Util.resolveColor(options.string);
}
function resolveGuild(options) {
    return options.client.guilds.cache.get(options.string);
}
function resolveUser(options) {
    const user = options.client.users.cache.find(u => u.id == options.string ||
        u.tag == options.string ||
        `<@!${u.id}>` == options.string ||
        `<@${u.id}>` == options.string);
    return user ? user : null;
}
async function resolveMember(options) {
    return await options.message.guild.members.fetch(resolveUser(options).id);
}
function resolveChannel(options) {
    const channel = options.client.channels.cache.find(c => c.id == options.string ||
        `<#!${c.id}>` == options.string ||
        `<#${c.id}>` == options.string);
    return channel ? channel : null;
}
async function resolveMessage(options) {
    const msg = options.message.channel.messages.cache.find(m => m.id == options.string || m.url == options.string);
    const msg2 = await options.message.channel.messages.fetch(options.string, {
        cache: true,
        force: true
    });
    return msg ? msg : msg2 ? msg2 : null;
}
async function resolveInvite(options) {
    const invite = options.message.guild.invites.cache.find(e => e.code == options.string || e.url == options.string);
    const invite2 = await options.message.guild.invites.fetch({
        code: options.string,
        force: true,
        cache: true
    });
    return invite ? invite : invite2 ? invite2 : null;
}
function resolveEmoji(options) {
    const emoji = options.client.emojis.cache.find(e => e.id == options.string ||
        e.name == options.string ||
        e.url == options.string);
    return emoji ? emoji : null;
}
function resolveRole(options) {
    const role = options.message.guild.roles.cache.find(r => r.id == options.string || r.name == options.string);
    return role ? role : null;
}
function resolvePermission(options) {
    if (!Object.keys(Discord.Permissions.FLAGS).includes(options.string.toUpperCase()))
        return null;
    return options.string.toUpperCase();
}
function resolveTime(options) {
    return fero_ms_1.ms(options.string);
}
function resolveCommand(options) {
    return options.client.commands.find(cmd => cmd.name.toLowerCase() == options.string.toLowerCase() ||
        cmd.aliases.map(lower).includes(options.string.toLowerCase()));
}
function lower(s) {
    return s.toLowerCase();
}
