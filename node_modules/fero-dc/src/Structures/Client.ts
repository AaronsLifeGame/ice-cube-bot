/**
 * MIT License
 *
 * Copyright (c) 2021 Ferotiq
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @format
 */

import * as Discord from "discord.js";
import * as dotenv from "dotenv";
dotenv.config();
import { FDCConsole, FDCError } from "./FDCConsole.js";
import { Command } from "./Command.js";
import { Event } from "./Event.js";
import * as fs from "fs";
import "colors";
import * as path from "path";
import { builtInHelpCommand } from "../Scripts/builtInHelpCommand.js";
import { ms } from "fero-ms";
import _ from "lodash";

interface HelpCommandStyle extends Discord.MessageEmbedOptions {
	slashCommand: boolean;
}

interface ClientOptions extends Discord.ClientOptions {
	tokenName: string;
	prefix: string;
	commandLoadedMessage?: boolean;
	eventLoadedMessage?: boolean;
	builtInHelpCommand?: HelpCommandStyle;
	deleteUnusedSlashCommands?: boolean;
	permissionData: object;
}

interface Paths {
	config: string;
	commands: string;
	events: string;
}

interface ConverterFunctionOptions {
	client: Client;
	string: string;
	message: Discord.Message;
	rest: string[];
}

type Perm = Discord.PermissionString | Discord.Permissions;

type Permission = Perm | Perm[];

type PrefixCollection =
	| Discord.Collection<string | Discord.Guild, string>
	| [string | Discord.Guild, string][]
	| Map<string | Discord.Guild, string>;

const none = [null, undefined];

export class Client extends Discord.Client {
	private fdcconsole: FDCConsole = new FDCConsole();
	public commands: Discord.Collection<string, Command<any>> =
		new Discord.Collection<string, Command<any>>();
	public discord: typeof Discord = Discord;
	public defaultPrefix: string;
	public prefixes: Discord.Collection<string, string> =
		new Discord.Collection<string, string>();
	public commandLoadedMessage: boolean;
	public eventLoadedMessage: boolean;
	public emitMessageOnInteraction: boolean;
	public builtInHelpCommand: HelpCommandStyle;
	public deleteUnusedSlashCommands: boolean;
	public paths: Paths;
	public modules: object;
	public permissionData: object;
	public config: ClientOptions;
	private started: boolean = false;
	private converters = {
		string: resolveString,
		mstring: resolveMString,
		quote: resolveQuote,
		char: resolveChar,
		number: resolveNumber,
		int: resolveInt,
		float: resolveNumber,
		boolean: resolveBoolean,
		color: resolveColor,
		guild: resolveGuild,
		member: resolveMember,
		user: resolveUser,
		channel: resolveChannel,
		message: resolveMessage,
		invite: resolveInvite,
		emoji: resolveEmoji,
		role: resolveRole,
		permission: resolvePermission,
		time: resolveTime,
		command: resolveCommand
	};
	public converterDescriptions = {
		string: "string",
		mstring: "string",
		char: "single character",
		number: "number",
		int: "integer (whole number)",
		float: "floating-point (decimal) number",
		boolean: "true/false",
		color: "hexadecimal color",
		guild: "server",
		member: "server member",
		user: "discord user",
		channel: "channel",
		message: "message",
		invite: "server invite",
		emoji: "emoji",
		role: "server role",
		permission: "permission string",
		time: "date",
		command: "fero-dc command"
	};

	public constructor(paths: Paths, modules: object = {}) {
		if (!fs.existsSync(paths.config)) {
			const toMake = path.join(paths.config, "../");
			fs.mkdirSync(toMake, { recursive: true });

			fs.writeFileSync(
				paths.config,
				JSON.stringify(
					{
						tokenName: "TOKEN",
						prefix: "!",
						permissionData: {},
						intents: ["GUILDS", "GUILD_MESSAGES"]
					},
					null,
					4
				)
			);
		}
		const envPath = path.join(process.cwd(), ".env");
		if (!fs.existsSync(envPath)) {
			fs.writeFileSync(envPath, "# Auto-Generated ENV\nTOKEN = BOTTOKEN");
			dotenv.config();
		}

		const config = JSON.parse(
			fs.readFileSync(paths.config)?.toString()
		) as ClientOptions;
		if (!config)
			throw new FDCError("You did not supply a valid config path!");
		super(config);

		this.defaultPrefix = config.prefix;

		if (!config.tokenName)
			throw new FDCError(
				"A token name in the config.json was not provided."
			);

		if (!process.env[config.tokenName || "TOKEN"])
			throw new FDCError(`No .env ${config.tokenName} was provided.`);

		const {
			commandLoadedMessage,
			eventLoadedMessage,
			builtInHelpCommand,
			deleteUnusedSlashCommands
		} = config;

		this.commandLoadedMessage = commandLoadedMessage;
		this.eventLoadedMessage = eventLoadedMessage;
		this.builtInHelpCommand = builtInHelpCommand;
		this.deleteUnusedSlashCommands = deleteUnusedSlashCommands;

		this.paths = paths;

		this.modules = modules;

		if (!config.permissionData)
			throw new FDCError(
				"Permission data in the config.json was not provided."
			);

		this.permissionData = config.permissionData;
		this.config = config;
	}

	async start() {
		if (this.started) return;
		this.started = true;
		Object.entries(this.paths).forEach(p => {
			if (!fs.existsSync(p[1])) {
				fs.mkdirSync(p[1], { recursive: true });
				this.fdcconsole.warn(
					`${p[0]} directory "${p[1]}" didn't exist, creating it...`
						.yellow
				);
			}
		});

		this.login(process.env[this.config.tokenName || "TOKEN"]);

		this.once("ready", async () => {
			this.fdcconsole.log(`${this.user.username} is online!`.magenta);
			const result = await this.reload();
			this.fdcconsole.log(result.blue);
		});
	}

	async reload(): Promise<string> {
		console.time("Fero-DC Reload");
		this.commands.clear();

		const slashCommands = await this.application.commands.fetch();

		console.timeLog("Fero-DC Reload", "Fetching SlashCommands");

		const commands = (
			await Promise.all(
				fs
					.readdirSync(this.paths.commands)
					.filter(file =>
						isJSOrDirectory(path.join(this.paths.commands, file))
					)
					.map(async folder => {
						if (isJS(folder))
							return require(path.join(
								this.paths.commands,
								folder
							)) as Command<any>;
						else
							return await Promise.all(
								fs
									.readdirSync(
										path.join(this.paths.commands, folder)
									)
									.filter(file => isJS(file))
									.map(
										file =>
											require(path.join(
												this.paths.commands,
												file
											)) as Command<any>
									)
							);
					})
			)
		)
			.flat(1)
			.map(
				cmd =>
					(typeof cmd["command"] == "object"
						? cmd["command"]
						: cmd) as Command<any>
			);

		commands.forEach(cmd => {
			if (!cmd || _.isEmpty(cmd) || !cmd.name)
				return this.fdcconsole.warn(
					"Command file with no command identified. Could not load."
				);
			this.commands.set(cmd.name, cmd);
			const slashCommand = slashCommands.find(
				c => c.name.toLowerCase() == cmd.name.toLowerCase()
			);
			if (cmd.isSlash() && !slashCommand) {
				this.application.commands.create({
					name: cmd.name,
					description: cmd.description,
					type: "CHAT_INPUT",
					options: cmd.slashCommandOptions,
					defaultPermission: true
				});
				this.fdcconsole.warn(
					`Command ${cmd.name} isn't registered as a slash command, creating it...`
						.yellow
				);
			} else if (cmd.isSlash() && slashCommand) {
				if (
					!(
						cmd.description == slashCommand.description &&
						arrayEquals(
							cmd.slashCommandOptions,
							slashCommand.options
						)
					)
				) {
					slashCommand.edit({
						name: cmd.name,
						description: cmd.description,
						type: "CHAT_INPUT",
						options: cmd.slashCommandOptions,
						defaultPermission: true
					});
					this.fdcconsole.log(
						`Edited slash command ${cmd.name}...`.green
					);
				}
			}
		});

		if (this.builtInHelpCommand) {
			const helpCommand = builtInHelpCommand(this);

			if (
				this.commands.find(
					cmd =>
						cmd.name.toLowerCase() == helpCommand.name ||
						cmd.aliases.map(lower).includes(helpCommand.name)
				)
			)
				throw new FDCError(
					"You are attempting to override a custom help command with the default help command, please choose one or the other."
				);

			this.commands.set(helpCommand.name, helpCommand);

			if (helpCommand.isSlash() && !helpCommand.slashCommandOptions)
				this.application.commands.create({
					name: helpCommand.name,
					description: helpCommand.description,
					type: "CHAT_INPUT",
					options: helpCommand.slashCommandOptions,
					defaultPermission: true
				});
		}

		console.timeLog(
			"Fero-DC Reload",
			"Commands and Editing/Deleting SlashCommands"
		);

		slashCommands.forEach(slashCommand => {
			const cmd = commands.find(
				cmd =>
					cmd.name.toLowerCase() == slashCommand.name.toLowerCase() &&
					cmd.isSlash()
			);
			if (
				!cmd &&
				this.deleteUnusedSlashCommands &&
				!(cmd.name == "help" && this.builtInHelpCommand)
			)
				slashCommand.delete() &&
					this.fdcconsole.warn(
						`Deleted slash command ${slashCommand.name}...`.yellow
					);
		});

		console.timeLog("Fero-DC Reload", "Creating SlashCommands");

		const events = (
			await Promise.all(
				fs
					.readdirSync(this.paths.events)
					.filter(file =>
						isJSOrDirectory(`${this.paths.events}/${file}`)
					)
					.map(async folder => {
						if (isJS(folder))
							return require(`${this.paths.events}/${folder}`) as Event<
								keyof Discord.ClientEvents
							>;
						else
							return await Promise.all(
								fs
									.readdirSync(
										`${this.paths.events}/${folder}`
									)
									.filter(file =>
										isJS(
											`${this.paths.events}/${folder}/${file}`
										)
									)
									.map(
										file =>
											require(`${this.paths.events}/${folder}/${file}`) as Event<
												keyof Discord.ClientEvents
											>
									)
							);
					})
			)
		)
			.flat(1)
			.map(
				event =>
					(typeof event.event == "object"
						? event.event
						: event) as Event<keyof Discord.ClientEvents>
			);

		this.removeAllListeners();

		events.forEach(event => {
			if (!event || _.isEmpty(event) || !event.event)
				return this.fdcconsole.warn(
					"Event file with no event identified. Could not load."
				);
			this.on(event.event, event.run.bind(null, this));
		});

		console.timeLog("Fero-DC Reload", "Events");

		console.table(
			Object.fromEntries(this.commands.map(cmd => [cmd.name, cmd])),
			[
				"description",
				"aliases",
				"permissions",
				"category",
				"type",
				"args",
				"slashCommandOptions"
			]
		);

		console.table(
			Object.fromEntries(events.map(event => [event.event, event])),
			["run"]
		);

		Object.assign(this, this.modules);

		console.timeEnd("Fero-DC Reload");
		this.emit("ready", this);
		return `Reloaded ${commands.length} commands, ${
			events.length
		} events, and ${Object.keys(this.modules).length} modules.`;
	}

	public checkPermissions(
		permissions: Permission[],
		member: Discord.GuildMember
	): boolean {
		if (!member || !(member instanceof Discord.GuildMember)) return false;

		return permissions.some(permission => {
			if (typeof permission == "string")
				return this.checkPermission(permission, member);
			else if (permission instanceof Array)
				return permission.every(perm =>
					this.checkPermission(perm, member)
				);
		});
	}

	private checkPermission(
		permission: Permission,
		member: Discord.GuildMember
	): boolean {
		if (this.users.cache.get(permission as string))
			return member.id == permission;
		else if (member.guild.roles.cache.get(permission as string))
			return member.roles.cache.has(permission as string);
		else if (this.permissionData[permission as string])
			return this.checkPermissions(
				this.permissionData[permission as string],
				member
			);
		else
			return member.permissions.has(
				permission as Discord.PermissionResolvable,
				true
			);
	}

	public async runCommand(
		command: Command<any>,
		message: Discord.Message,
		args: string[]
	): Promise<void> {
		const conversions =
			(await Promise.all(
				command.args.map(
					async (argument, index) =>
						await this.converters[argument.type]({
							client: this as any,
							string: args[index],
							message: message as any,
							rest: args.slice(index + 1)
						})
				)
			)) || [];

		return command.run(message, args, this, ...conversions);
	}

	public getCommandsFromCategory(category: string) {
		return this.commands.filter(command => command.category == category);
	}

	public getCommandUsage(command: Command<any>, guild: Discord.Guild = null) {
		if (!command) return;
		const prefix = this.prefix(guild);

		const cmdArgs = command.args
			.map(
				commandArg =>
					`<${commandArg.name}${
						commandArg.required ?? true ? "" : "?"
					}: ${commandArg.type}>`
			)
			.join(" ");

		return (
			command.usage ||
			`${prefix}${command.name}${cmdArgs == "" ? "" : " " + cmdArgs}`
		);
	}

	public prefix(guild: Discord.Guild | string = null) {
		return guild
			? typeof guild == "string"
				? this.prefixes.get(guild) || this.defaultPrefix
				: this.prefixes.get(guild.id) || this.defaultPrefix
			: this.defaultPrefix;
	}

	public loadPrefixes(...iterators: PrefixCollection[]) {
		iterators.forEach(iterator => {
			if (iterator instanceof Discord.Collection) {
				iterator.forEach((v, k) => {
					if (typeof v != "string") return;
					if (typeof k != "string" && !(k instanceof Discord.Guild))
						return;
					if (k instanceof Discord.Guild) this.prefixes.set(k.id, v);
					else this.prefixes.set(k, v);
				});
			} else if (iterator instanceof Array) {
				iterator.forEach(i => {
					const [k, v] = i;
					if (typeof v != "string") return;

					if (typeof k != "string" && !(k instanceof Discord.Guild))
						return;
					if (k instanceof Discord.Guild) this.prefixes.set(k.id, v);
					else this.prefixes.set(k, v);
				});
			} else if (iterator instanceof Map) {
				iterator.forEach((v, k) => {
					if (typeof v != "string") return;
					if (typeof k != "string" && !(k instanceof Discord.Guild))
						return;
					if (k instanceof Discord.Guild) this.prefixes.set(k.id, v);
					else this.prefixes.set(k, v);
				});
			} else if (typeof iterator == "object") {
				Object.entries(iterator).forEach(i => {
					const [k, v] = i;
					if (typeof v != "string" || typeof k != "string") return;
					this.prefixes.set(k, v);
				});
			} else
				throw new FDCError(
					"loadPrefixes was not passed an object, array, map, or collection."
				);
		});

		return this.prefixes;
	}

	public get commandCategories() {
		return [
			...new Set(
				this.commands
					.map(c => c.category)
					.filter(c => !none.includes(c))
			)
		];
	}
}

function isJS(fileName: string): boolean {
	return [".js", ".ts"].includes(path.extname(fileName));
}

function isDirectory(filePath: string): boolean {
	return fs.lstatSync(filePath).isDirectory();
}

function isJSOrDirectory(filePath: string): boolean {
	return isJS(filePath) || isDirectory(filePath);
}

function arrayEquals<T>(a: Array<T>, b: Array<T>) {
	return a.every((val, index) => _.isEqual(val, b[index]));
}

function resolveString(options: ConverterFunctionOptions) {
	return options.string;
}

function resolveMString(options: ConverterFunctionOptions) {
	return (options.string + " " + options.rest.join(" ")).trim();
}

const regex = /"([^"]+)"/;

function resolveQuote(options: ConverterFunctionOptions) {
	const matches = resolveMString(options).match(regex);
	if (!matches) return null;
	return matches[1];
}

function resolveChar(options: ConverterFunctionOptions) {
	return options.string[0] ?? null;
}

function resolveNumber(options: ConverterFunctionOptions) {
	return parseFloat(options.string);
}

function resolveInt(options: ConverterFunctionOptions) {
	return parseInt(options.string);
}

const falsy = [
	"false",
	"0",
	"0n",
	"undefined",
	"NaN",
	"",
	"no",
	"off",
	...none
];

function resolveBoolean(options: ConverterFunctionOptions) {
	return none.includes(options.string)
		? null
		: !falsy.includes(options.string);
}

function resolveColor(options: ConverterFunctionOptions) {
	return Discord.Util.resolveColor(options.string as Discord.ColorResolvable);
}

function resolveGuild(options: ConverterFunctionOptions) {
	return options.client.guilds.cache.get(options.string);
}

function resolveUser(options: ConverterFunctionOptions) {
	const user = options.client.users.cache.find(
		u =>
			u.id == options.string ||
			u.tag == options.string ||
			`<@!${u.id}>` == options.string ||
			`<@${u.id}>` == options.string
	);
	return user ? user : null;
}

async function resolveMember(options: ConverterFunctionOptions) {
	return await options.message.guild.members.fetch(resolveUser(options).id);
}

function resolveChannel(options: ConverterFunctionOptions) {
	const channel = options.client.channels.cache.find(
		c =>
			c.id == options.string ||
			`<#!${c.id}>` == options.string ||
			`<#${c.id}>` == options.string
	);
	return channel ? channel : null;
}

async function resolveMessage(options: ConverterFunctionOptions) {
	const msg = options.message.channel.messages.cache.find(
		m => m.id == options.string || m.url == options.string
	);

	const msg2 = await options.message.channel.messages.fetch(options.string, {
		cache: true,
		force: true
	});

	return msg ? msg : msg2 ? msg2 : null;
}

async function resolveInvite(options: ConverterFunctionOptions) {
	const invite = options.message.guild.invites.cache.find(
		e => e.code == options.string || e.url == options.string
	);

	const invite2 = await options.message.guild.invites.fetch({
		code: options.string,
		force: true,
		cache: true
	});

	return invite ? invite : invite2 ? invite2 : null;
}

function resolveEmoji(options: ConverterFunctionOptions) {
	const emoji = options.client.emojis.cache.find(
		e =>
			e.id == options.string ||
			e.name == options.string ||
			e.url == options.string
	);
	return emoji ? emoji : null;
}

function resolveRole(options: ConverterFunctionOptions) {
	const role = options.message.guild.roles.cache.find(
		r => r.id == options.string || r.name == options.string
	);
	return role ? role : null;
}

function resolvePermission(options: ConverterFunctionOptions) {
	if (
		!Object.keys(Discord.Permissions.FLAGS).includes(
			options.string.toUpperCase()
		)
	)
		return null;

	return options.string.toUpperCase();
}

function resolveTime(options: ConverterFunctionOptions): Date {
	return ms(options.string);
}

function resolveCommand(options: ConverterFunctionOptions) {
	return options.client.commands.find(
		cmd =>
			cmd.name.toLowerCase() == options.string.toLowerCase() ||
			cmd.aliases.map(lower).includes(options.string.toLowerCase())
	);
}

function lower(s: string) {
	return s.toLowerCase();
}
